package com.example.demo.controller;

import com.example.demo.models.CustomerRequest;
import com.example.demo.models.CustomerResponse;
import com.example.demo.validations.EmailOrAddressValidator;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@RestController
@RequestMapping("/api/v1")
@AllArgsConstructor
@Validated
@Slf4j
public class CustomerController {

    private final EmailOrAddressValidator emailOrAddressValidator;
    private final List<CustomerResponse> customers = new ArrayList<>();

    @PostMapping("/customer")
    ResponseEntity<CustomerResponse> createCustomer(@RequestBody @Valid CustomerRequest customerRequest) {
        if (!emailOrAddressValidator.isValid(customerRequest)) {
            throw new IllegalArgumentException("Missing or invalid required fields.");
            //return ResponseEntity.badRequest().body("Missing or invalid required fields.");
        }
        // when service is implemented verify that the customer doesn't exist? or map the duplicated primary key ? what is the primary key ?!
        // The id will be generated by a dedicated service
        CustomerResponse response = new CustomerResponse(customerRequest.getFirstName(), customerRequest.getFirstName(),
                customerRequest.getLastName(), customerRequest.getAge());
        response.setEmail(customerRequest.getEmail());
        response.setCurrentLivingAddress(customerRequest.getCurrentLivingAddress());
        customers.add(response);
        return ResponseEntity.created(URI.create("/api/v1/customer/" + response.getId())).body(response);

    }

    @GetMapping("/customers")
    List<CustomerResponse> getAllCustomers() {
        return customers;
    }

    @GetMapping("/customer/{id}")
    ResponseEntity<CustomerResponse> getCustomer(@PathVariable String id) {
        return customers.stream()
                .filter(cust -> cust.getFirstName().equals(id))
                .findFirst()
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());

    }

    @GetMapping("/customer/find")
    ResponseEntity<List<CustomerResponse>> findCustomerByName(@RequestParam(name = "first_name", required = false) String firstName,
                                                              @RequestParam(name = "last_name", required = false) String lastName) {
        // If no search criteria provided then default to a bad request
        if (firstName == null && lastName == null) {
            return ResponseEntity.badRequest().build();
        }
        // What if both criteria are provided ?
        return ResponseEntity.ok(Stream.concat(
                        (firstName == null) ? Stream.empty() : customers.stream().filter(cust -> cust.getFirstName().equals(firstName)),
                        (lastName == null) ? Stream.empty() : customers.stream().filter(cust -> cust.getLastName().equals(lastName)))
                .collect(Collectors.toList()));

    }
}
